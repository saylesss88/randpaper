use anyhow::Context;
use std::fmt::Write;
use std::fs;
use std::path::{Path, PathBuf};

#[derive(Clone, Copy, Debug)]
struct Rgb {
    r: u8,
    g: u8,
    b: u8,
}

impl Rgb {
    fn hex(self) -> String {
        format!("#{:02x}{:02x}{:02x}", self.r, self.g, self.b)
    }

    fn luminance(self) -> f32 {
        0.2126f32.mul_add(f32::from(self.r), 0.7152 * f32::from(self.g))
    }

    fn saturation_proxy(self) -> u8 {
        // cheap “how colorful is this” proxy: max-min
        let max = self.r.max(self.g).max(self.b);
        let min = self.r.min(self.g).min(self.b);
        max - min
    }
}

fn pick_roles(colors: &[Rgb]) -> (Rgb, Rgb, Rgb, Rgb, Rgb) {
    // bg = darkest, fg = lightest
    let mut sorted = colors.to_vec();
    sorted.sort_by(|a, b| a.luminance().total_cmp(&b.luminance()));
    let bg = sorted[0];
    let fg = *sorted.last().unwrap_or(&Rgb {
        r: 225,
        g: 225,
        b: 225,
    });

    // accent = most “saturated” among the remaining
    let accent = sorted
        .iter()
        .copied()
        .max_by_key(|c| c.saturation_proxy())
        .unwrap_or(fg);

    // warn/ok: pick two reasonably distinct colors (fallbacks)
    let warn = sorted.get(2).copied().unwrap_or(accent);
    let ok = sorted.get(4).copied().unwrap_or(accent);

    (bg, fg, accent, warn, ok)
}

pub fn write_waybar_css(
    theme_dir: &Path,
    palette: &[color_thief::Color],
) -> anyhow::Result<PathBuf> {
    let colors: Vec<Rgb> = palette
        .iter()
        .map(|c| Rgb {
            r: c.r,
            g: c.g,
            b: c.b,
        })
        .collect();

    let (bg, fg, accent, warn, ok) = pick_roles(&colors);

    let mut css = String::new();
    let _ = writeln!(css, "/* auto-generated by randpaper */");
    let _ = writeln!(css, "@define-color rp_bg {};", bg.hex());
    let _ = writeln!(css, "@define-color rp_fg {};", fg.hex());
    let _ = writeln!(css, "@define-color rp_accent {};", accent.hex());
    let _ = writeln!(css, "@define-color rp_warn {};", warn.hex());
    let _ = writeln!(css, "@define-color rp_ok {};", ok.hex());
    let _ = writeln!(css, "@define-color rp_border {};", accent.hex());
    let _ = writeln!(css, "@define-color rp_muted {};", bg.hex());

    fs::create_dir_all(theme_dir)?;
    let out = theme_dir.join("waybar.css");
    fs::write(&out, css)?;
    Ok(out)
}

pub fn update_theme_file(image_path: &Path) -> anyhow::Result<()> {
    let img = image::open(image_path).context("Failed to open image for theming")?;
    let img = img.resize(300, 300, image::imageops::FilterType::Nearest);
    let buffer = img.to_rgb8();

    let palette = color_thief::get_palette(
        buffer.as_raw(),
        color_thief::ColorFormat::Rgb,
        10,
        16, // <-- was 8
    )
    .map_err(|e| anyhow::anyhow!("Color thief error: {e:?}"))?;

    // Build role colors once for consistent bg/fg/accent across everything
    let colors: Vec<Rgb> = palette
        .iter()
        .map(|c| Rgb {
            r: c.r,
            g: c.g,
            b: c.b,
        })
        .collect();
    let (bg, fg, _accent, _warn, _ok) = pick_roles(&colors);

    let theme_dir = dirs::config_dir()
        .ok_or_else(|| anyhow::anyhow!("Could not find config directory"))?
        .join("randpaper/themes");
    fs::create_dir_all(&theme_dir)?;

    // Generate Waybar CSS
    let _ = write_waybar_css(&theme_dir, &palette)?;

    std::process::Command::new("sh")
        .arg("-c")
        .arg("pkill -USR2 waybar")
        .spawn()
        .context("Failed to reload waybar reload")?;

    // Terminal configs
    let mut ghostty = String::from("# Auto-generated by randpaper\n");
    let mut kitty = String::from("# Auto-generated by randpaper\n");
    let mut foot = String::from("# Auto-generated by randpaper\n[colors]\n");

    for (i, color) in palette.iter().enumerate() {
        let hex = format!("{:02x}{:02x}{:02x}", color.r, color.g, color.b);

        let _ = writeln!(ghostty, "palette = {i}=#{hex}");
        let _ = writeln!(kitty, "color{i} #{hex}");

        if i < 8 {
            let _ = writeln!(foot, "regular{i}={hex}");
        } else {
            let _ = writeln!(foot, "bright{}={hex}", i - 8);
        }
    }

    // Use role-based bg/fg (more reliable)
    let _ = writeln!(ghostty, "background = {}", bg.hex());
    let _ = writeln!(ghostty, "foreground = {}", fg.hex());

    let _ = writeln!(kitty, "background {}", bg.hex());
    let _ = writeln!(kitty, "foreground {}", fg.hex());

    // foot.ini wants hex without '#'
    let _ = writeln!(foot, "background={:02x}{:02x}{:02x}", bg.r, bg.g, bg.b);
    let _ = writeln!(foot, "foreground={:02x}{:02x}{:02x}", fg.r, fg.g, fg.b);

    fs::write(theme_dir.join("ghostty.config"), ghostty)?;
    fs::write(theme_dir.join("kitty.conf"), kitty)?;
    fs::write(theme_dir.join("foot.ini"), foot)?;

    log::info!("Updated themes in {}", theme_dir.display());
    Ok(())
}
