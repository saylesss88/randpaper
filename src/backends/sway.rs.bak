// Robust Sway backend:
// - Uses swayipc_async first (pure Rust IPC).
// - If it errors or times out, falls back to `swaymsg -t get_outputs -r`.
// - Never mutates SWAYSOCK env (avoids global races).
use crate::traits::Backend;
use anyhow::{Context, bail};
use async_trait::async_trait;
use std::{env, fs, path::PathBuf, time::SystemTime};
use swayipc_async::Connection;
use tokio::time::{Duration, timeout};

pub struct SwayBackend {
    pub outputs_override: Vec<String>,
}

fn candidate_sockets() -> Vec<PathBuf> {
    let base = std::env::var_os("XDG_RUNTIME_DIR").map_or_else(
        || {
            let uid = unsafe { libc::getuid() };
            PathBuf::from(format!("/run/user/{uid}"))
        },
        PathBuf::from,
    );

    let mut socks: Vec<(SystemTime, PathBuf)> = Vec::new();

    if let Ok(rd) = fs::read_dir(base) {
        for ent in rd.flatten() {
            let p = ent.path();
            let name_ok = p.file_name().and_then(|s| s.to_str()).is_some_and(|s| {
                s.starts_with("sway-ipc.")
                    && std::path::Path::new(s)
                        .extension()
                        .is_some_and(|ext| ext.eq_ignore_ascii_case("sock"))
            });
            if !name_ok {
                continue;
            }

            let mtime = ent
                .metadata()
                .and_then(|m| m.modified())
                .unwrap_or(SystemTime::UNIX_EPOCH);

            socks.push((mtime, p));
        }
    }

    socks.sort_by(|a, b| b.0.cmp(&a.0)); // newest first
    socks.into_iter().map(|(_, p)| p).collect()
}

async fn connect_with_env_socket(sock: &PathBuf) -> anyhow::Result<Connection> {
    // SAFETY: This is safe as long as no other threads are concurrently
    // accessing the environment (e.g., via getenv).
    unsafe {
        env::set_var("SWAYSOCK", sock);
    }

    Connection::new()
        .await
        .with_context(|| format!("sway ipc: connect using SWAYSOCK={}", sock.display()))
}

#[async_trait]
impl Backend for SwayBackend {
    async fn get_active_monitors(&self) -> anyhow::Result<Vec<String>> {
        if !self.outputs_override.is_empty() {
            return Ok(self.outputs_override.clone());
        }

        // 1) Try current env (fast path)
        // let mut conn = match Connection::new()
        //     .await
        //     .context("sway ipc: connect using existing SWAYSOCK/I3SOCK env")
        let mut conn = timeout(Duration::from_secs(1), Connection::new())
            .await
            .context("sway ipc: connect timed out")??;
        let outputs = timeout(Duration::from_secs(1), conn.get_outputs())
            .await
            .context("sway ipc: get_outputs timed out")??;
        // {
        //     Ok(c) => c,
        //     Err(first_err) => {
        //         // 2) Retry with discovered sockets
        //         let mut last_err: anyhow::Error = first_err;

        //         let socks = candidate_sockets();
        //         if socks.is_empty() {
        //             bail!("sway ipc: no sway-ipc.*.sock found under runtime dir");
        //         }

        //         let mut connected: Option<Connection> = None;
        //         for sock in socks {
        //             match connect_with_env_socket(&sock).await {
        //                 Ok(c) => {
        //                     connected = Some(c);
        //                     break;
        //                 }
        //                 Err(e) => last_err = e,
        //             }
        //         }

        //         connected
        //             .ok_or(last_err)
        //             .context("sway ipc: failed to connect after trying discovered sockets")?
        //     }
        // };

        // let outputs = conn.get_outputs().await.context("sway ipc: get_outputs")?;

        Ok(outputs
            .into_iter()
            .filter(|o| o.active)
            .map(|o| o.name)
            .collect())
    }
}
